#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema Integrado: calculo_entradas_v55.py com Threading e Monitoramento
Este sistema combina o c√≥digo original com threading para visualiza√ß√£o completa
Vers√£o corrigida - apenas opera√ß√µes reais
"""

import threading
import time
import json
import sys
import os
from datetime import datetime
import traceback

# Importa todo o c√≥digo original
sys.path.append('.')

class SistemaIntegrado:
    """Sistema que integra o c√≥digo original com threading"""
    
    def __init__(self):
        self.running = False
        self.thread_principal = None
        self.dados_sistema = {
            "execucoes": 0,
            "pares_processados": 0,
            "ordens_enviadas": 0,
            "inicio": None,
            "ultimo_ciclo": None,
            "status": "Desconectado"
        }
        self.logs = []
        
        # Controles para as novas threads
        self.stops_ja_ajustados = set()
        self.ajustes_executados_hoje = set()
        
        # Configura√ß√µes hor√°rio
        self.JANELA_BREAK_EVEN = (8, 17)  # 8h-17h: Break-even autom√°tico
        self.horario_ajuste_stops = 15    # 15h - Ajustar stops
        self.ajusta_ordens_minuto = 10    # 15:10h - Minuto para ajustes
        self.horario_remove_pendentes = 15 # 15h - Remover ordens pendentes (15:20h)
        self.horario_fechamento_total = 16 # 16h - Fechamento for√ßado (16:01h)
        self.prefixo = "2"                # Prefixo do magic number
    
    def log(self, mensagem):
        """Log com timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        evento = f"[{timestamp}] {mensagem}"
        self.logs.append(evento)
        print(evento)
    
    def executar_sistema_original(self):
        """Executa o sistema original em thread separada"""
        self.log("INICIANDO: Sistema Original de Trading")
        
        try:
            # Tenta ler o arquivo original com diferentes encodings
            codigo = None
            encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
            
            for encoding in encodings:
                try:
                    with open('calculo_entradas_v55.py', 'r', encoding=encoding) as f:
                        codigo = f.read()
                    self.log(f"‚úÖ Arquivo lido com encoding: {encoding}")
                    break
                except UnicodeDecodeError:
                    continue
                except FileNotFoundError:
                    self.log("‚ùå Arquivo calculo_entradas_v55.py n√£o encontrado")
                    raise
            
            if codigo is None:
                raise UnicodeDecodeError("N√£o foi poss√≠vel ler o arquivo com nenhum encoding")
            
            # Remove caracteres problem√°ticos se necess√°rio
            codigo = codigo.replace('\x92', "'").replace('\x96', '-').replace('\x91', "'")
            # Executa o c√≥digo original
            exec(codigo, globals())
            self.log("‚úÖ Sistema original executado com sucesso")
            
        except FileNotFoundError:
            self.log("‚ùå ERRO: Arquivo calculo_entradas_v55.py n√£o encontrado")
            self.log("   üìã Sistema funcionar√° apenas com monitoramento de posi√ß√µes reais")
        except UnicodeDecodeError as e:
            self.log("‚ùå ERRO: Problema de encoding no arquivo original")
            self.log(f"   üìã Detalhes: {str(e)}")
            self.log("   üìã Sistema funcionar√° apenas com monitoramento de posi√ß√µes reais")
        except Exception as e:
            self.log(f"‚ùå ERRO: Falha na execu√ß√£o: {str(e)}")
            self.log("   üìã Sistema funcionar√° apenas com monitoramento de posi√ß√µes reais")
            
    def thread_monitoramento(self):
        """Thread de monitoramento do sistema"""
        self.log("üìä INICIANDO: Thread de monitoramento")
        
        while self.running:
            try:
                # Relat√≥rio a cada 2 minutos
                self.log("üìã RELAT√ìRIO DE MONITORAMENTO:")
                self.log(f"   ‚ö° Execu√ß√µes: {self.dados_sistema['execucoes']}")
                self.log(f"   üìà Pares processados: {self.dados_sistema['pares_processados']}")
                self.log(f"   üìù Ordens enviadas: {self.dados_sistema['ordens_enviadas']}")
                self.log(f"   üîÑ Status: {self.dados_sistema['status']}")
                
                if self.dados_sistema['ultimo_ciclo']:
                    tempo_ultimo = (datetime.now() - self.dados_sistema['ultimo_ciclo']).seconds
                    self.log(f"   ‚è∞ √öltimo ciclo: {tempo_ultimo}s atr√°s")
                
                # Simula checagem de sa√∫de do sistema
                if self.dados_sistema['execucoes'] > 0:
                    taxa_sucesso = (self.dados_sistema['pares_processados'] / 
                                   (self.dados_sistema['execucoes'] * 5)) * 100
                    self.log(f"   ‚úÖ Taxa de sucesso: {taxa_sucesso:.1f}%")
                
                time.sleep(120)  # A cada 2 minutos
                
            except Exception as e:
                self.log(f"‚ùå ERRO no monitoramento: {str(e)}")
                time.sleep(60)
    
    def thread_monitoramento_posicoes(self):
        """Thread espec√≠fica para monitoramento de posi√ß√µes - baseada no bloco do calculo_entradas_v55.py"""
        self.log("üîç INICIANDO: Thread de monitoramento de posi√ß√µes")
        
        # Importa√ß√µes necess√°rias para MT5 (se dispon√≠vel)
        try:
            import MetaTrader5 as mt5
            mt5_disponivel = True
            self.log("‚úÖ MetaTrader5 importado com sucesso")
        except ImportError:
            mt5_disponivel = False
            self.log("‚ö†Ô∏è MetaTrader5 n√£o dispon√≠vel - sistema n√£o pode operar")
            return
        
        while self.running:
            try:
                self.log("üîç VERIFICA√á√ÉO DE POSI√á√ïES E ORDENS PENDENTES")
                
                if mt5_disponivel:
                    # Executa monitoramento real com MT5
                    self.executar_monitoramento_real()
                else:
                    # MT5 n√£o dispon√≠vel - apenas aguarda
                    self.log("‚ö†Ô∏è MetaTrader5 n√£o dispon√≠vel - aguardando conex√£o...")
                
                # Aguarda pr√≥ximo ciclo (30 segundos para monitoramento mais frequente)
                for i in range(30):
                    if not self.running:
                        break
                    time.sleep(1)
                
            except Exception as e:
                self.log(f"‚ùå ERRO no monitoramento de posi√ß√µes: {str(e)}")
                time.sleep(60)
    
    def obter_pares_configurados(self):
        """Obt√©m pares configurados analisando posi√ß√µes reais do MT5"""
        try:
            import MetaTrader5 as mt5
            
            # Primeiro tenta acessar a vari√°vel global 'pares' do c√≥digo original
            if 'pares' in globals() and globals()['pares']:
                self.log("‚úÖ Usando vari√°vel 'pares' do sistema original")
                return globals()['pares']
            
            # Se n√£o encontrou, analisa posi√ß√µes reais do MT5 para inferir pares
            self.log("üìã Analisando posi√ß√µes reais do MT5 para identificar pares...")
            pares_inferidos = {}
            
            # Obt√©m todas as posi√ß√µes abertas
            posicoes_abertas = mt5.positions_get()
            
            if posicoes_abertas:
                # Agrupa posi√ß√µes por magic number
                magics_posicoes = {}
                for pos in posicoes_abertas:
                    if str(pos.magic).startswith(self.prefixo):
                        magic = pos.magic
                        if magic not in magics_posicoes:
                            magics_posicoes[magic] = []
                        magics_posicoes[magic].append(pos.symbol)
                
                # Para cada magic, identifica os pares (se houver m√∫ltiplas posi√ß√µes)
                for magic, symbols in magics_posicoes.items():
                    unique_symbols = list(set(symbols))  # Remove duplicatas
                    
                    if len(unique_symbols) == 2:
                        # Par completo identificado
                        pares_inferidos[magic] = (unique_symbols[0], unique_symbols[1])
                        self.log(f"üìå Par completo identificado - Magic {magic}: {unique_symbols[0]} / {unique_symbols[1]}")
                    elif len(unique_symbols) == 1:
                        # Apenas uma perna, tenta inferir o par baseado no hist√≥rico do sistema original
                        # Para posi√ß√µes √≥rf√£s, marca como None para fechamento
                        self.log(f"‚ö†Ô∏è Posi√ß√£o √≥rf√£ detectada - Magic {magic}: {unique_symbols[0]} (ser√° fechada)")
                        pares_inferidos[magic] = (unique_symbols[0], None)
            
            # Tamb√©m verifica ordens pendentes para completar informa√ß√µes
            ordens_pendentes = mt5.orders_get()
            if ordens_pendentes:
                for ordem in ordens_pendentes:
                    if str(ordem.magic).startswith(self.prefixo):
                        magic = ordem.magic
                        
                        # Se j√° temos posi√ß√£o aberta para este magic, complementa com ordem pendente
                        if magic in pares_inferidos and pares_inferidos[magic][1] is None:
                            posicao_atual = pares_inferidos[magic][0]
                            if ordem.symbol != posicao_atual:
                                pares_inferidos[magic] = (posicao_atual, ordem.symbol)
                                self.log(f"üìå Par completado com ordem pendente - Magic {magic}: {posicao_atual} / {ordem.symbol}")
            
            if pares_inferidos:
                self.log(f"‚úÖ {len(pares_inferidos)} pares identificados das posi√ß√µes reais")
                return pares_inferidos
            else:
                self.log("üìã Nenhuma posi√ß√£o do sistema encontrada no MT5")
                return {}
            
        except Exception as e:
            self.log(f"‚ùå Erro ao obter pares configurados: {str(e)}")
            return {}

    def executar_monitoramento_real(self):
        """Executa monitoramento real de posi√ß√µes com MT5"""
        import MetaTrader5 as mt5
        
        try:
            # Obt√©m posi√ß√µes e ordens pendentes
            posicoes_abertas = mt5.positions_get()
            posicoes_pendentes = mt5.orders_get()
            
            if posicoes_abertas is not None and len(posicoes_abertas) > 0:
                self.log(f"üìä N√∫mero de opera√ß√µes em aberto: {len(posicoes_abertas)}")
                
                # Prefixo do script (configur√°vel)
                prefixo_script = self.prefixo  # Usa o prefixo da configura√ß√£o da classe
                
                # Filtra apenas as posi√ß√µes com magic prefixo espec√≠fico
                def magic_comeca_com(magic, prefixo):
                    return str(magic).startswith(prefixo)
                
                magics_abertas = set(p.magic for p in posicoes_abertas if magic_comeca_com(p.magic, prefixo_script))
                
                for magic in magics_abertas:
                    pos_magic = [p for p in posicoes_abertas if p.magic == magic]
                    
                    # Se apenas uma perna do par est√° aberta
                    if len(pos_magic) == 1:
                        posicao = pos_magic[0]
                        ativo_aberto = posicao.symbol
                        
                        self.log(f"‚ö†Ô∏è Magic {magic}: Apenas uma perna aberta ({ativo_aberto})")
                        
                        # Busca o par configurado
                        pares = self.obter_pares_configurados()
                        depende_atual, independe_atual = pares.get(magic, (None, None))
                        
                        if depende_atual is None or independe_atual is None:
                            self.log(f"[AVISO] Par de ativos n√£o encontrado para magic {magic}. Fechando posi√ß√£o √≥rf√£...")
                            # Fecha a posi√ß√£o √≥rf√£ diretamente
                            self.programar_fechamento_posicao(magic, posicoes_abertas, posicoes_pendentes)
                            continue
                        
                        # Se o ativo aberto N√ÉO for o dependente, fecha o restante (independente)
                        if ativo_aberto != depende_atual:
                            self.log(f"üìå Magic={magic}: ativo dependente ({depende_atual}) j√° foi fechado.")
                            self.log(f"   Fechando perna remanescente ({ativo_aberto})...")
                            self.programar_fechamento_posicao(magic, posicoes_abertas, posicoes_pendentes)
                        
                        # Se o ativo aberto √â o dependente, verifica ordens pendentes do independente
                        elif ativo_aberto == depende_atual:
                            ordens_pendentes_indep = [o for o in posicoes_pendentes 
                                                    if o.symbol == independe_atual and o.magic == magic] if posicoes_pendentes else []
                            
                            if ordens_pendentes_indep:
                                self.log(f"üîÑ Magic={magic}: Dependente aberto, convertendo ordem pendente do independente para mercado")
                                self.converter_ordem_pendente_para_mercado(magic, posicao, ordens_pendentes_indep, independe_atual)
                
                # Calcula lucros/preju√≠zos por magic
                self.calcular_lucros_por_magic(magics_abertas, posicoes_abertas)
            else:
                self.log("‚úÖ Nenhuma posi√ß√£o aberta no momento")
                
        except Exception as e:
            self.log(f"‚ùå ERRO no monitoramento real: {str(e)}")
       
    def programar_fechamento_posicao(self, magic, posicoes_abertas, posicoes_pendentes=None):
        """Programa fechamento de posi√ß√£o - implementa√ß√£o real baseada no calculo_entradas_v55.py"""
        import MetaTrader5 as mt5
        
        self.log(f"üîÑ Executando fechamento para Magic {magic}")
        
        try:
            # FECHA POSI√á√ïES ABERTAS (baseado na fun√ß√£o fechar_posicoes do calculo_entradas_v55.py)
            if posicoes_abertas:
                for posicao in posicoes_abertas:
                    if posicao.magic == magic:
                        symbol = posicao.symbol
                        type_pos = posicao.type
                        volume = posicao.volume

                        # Determina tipo de ordem para fechamento
                        if type_pos == mt5.POSITION_TYPE_BUY:
                            price = mt5.symbol_info_tick(symbol).bid
                            order_type = mt5.ORDER_TYPE_SELL
                        else:
                            price = mt5.symbol_info_tick(symbol).ask
                            order_type = mt5.ORDER_TYPE_BUY

                        # Prepara requisi√ß√£o de fechamento (sem comment para evitar erro)
                        request = {
                            "action": mt5.TRADE_ACTION_DEAL,
                            "symbol": symbol,
                            "volume": volume,
                            "type": order_type,
                            "position": posicao.ticket,
                            "price": price,
                            "magic": posicao.magic,
                            "type_time": mt5.ORDER_TIME_GTC,
                            "type_filling": mt5.ORDER_FILLING_IOC,
                        }
                        
                        # Executa fechamento
                        result = mt5.order_send(request)
                        if result is None:
                            self.log(f"‚ùå [ERRO] order_send retornou None ao fechar posi√ß√£o ticket={posicao.ticket}")
                            self.log(f"   √öltimo erro: {mt5.last_error()}")
                        elif result.retcode != mt5.TRADE_RETCODE_DONE:
                            self.log(f"‚ùå Erro ao fechar posi√ß√£o {posicao.ticket}, retcode={result.retcode}")
                        else:
                            self.log(f"‚úÖ Posi√ß√£o ticket={posicao.ticket} ({symbol}) fechada com sucesso")

            # CANCELA ORDENS PENDENTES (baseado na fun√ß√£o fechar_posicoes do calculo_entradas_v55.py)
            if posicoes_pendentes:
                for ordem in posicoes_pendentes:
                    if ordem.magic == magic:
                        symbol = ordem.symbol

                        # Prepara requisi√ß√£o de cancelamento (sem comment para evitar erro)
                        request = {
                            "action": mt5.TRADE_ACTION_REMOVE,
                            "order": ordem.ticket,
                            "symbol": symbol,
                            "magic": ordem.magic,
                            "type_time": mt5.ORDER_TIME_GTC,
                            "type_filling": mt5.ORDER_FILLING_IOC,
                        }
                        
                        # Executa cancelamento
                        result = mt5.order_send(request)
                        if result is None:
                            self.log(f"‚ùå [ERRO] order_send retornou None ao cancelar ordem pendente={ordem.ticket}")
                            self.log(f"   √öltimo erro: {mt5.last_error()}")
                        elif result.retcode != mt5.TRADE_RETCODE_DONE:
                            self.log(f"‚ùå Erro ao cancelar ordem pendente {ordem.ticket}, retcode={result.retcode}")
                        else:
                            self.log(f"‚úÖ Ordem pendente ticket={ordem.ticket} ({symbol}) cancelada com sucesso")
                            
        except Exception as e:
            self.log(f"‚ùå ERRO no fechamento de posi√ß√µes: {str(e)}")
    
    def converter_ordem_pendente_para_mercado(self, magic, posicao, ordens_pendentes, independe_atual):
        """Converte ordem pendente para ordem a mercado - implementa√ß√£o real baseada no calculo_entradas_v55.py"""
        import MetaTrader5 as mt5
        
        self.log(f"üîÑ Convertendo ordem pendente para mercado: {independe_atual} (Magic {magic})")
        
        try:
            for ordem in ordens_pendentes:
                # 1. CANCELA A ORDEM PENDENTE
                cancel_request = {
                    "action": mt5.TRADE_ACTION_REMOVE,
                    "order": ordem.ticket,
                }
                result_cancel = mt5.order_send(cancel_request)
                
                if result_cancel and result_cancel.retcode == mt5.TRADE_RETCODE_DONE:
                    self.log(f"‚úÖ [OK] Ordem pendente do independente ({independe_atual}) cancelada para magic {magic}")
                else:
                    self.log(f"‚ùå [ERRO] Falha ao cancelar ordem pendente do independente ({independe_atual}) para magic {magic}")
                    continue

                # 2. ENVIA ORDEM A MERCADO PARA O INDEPENDENTE
                symbol_info_tick = mt5.symbol_info_tick(independe_atual)
                if not symbol_info_tick:
                    self.log(f"‚ùå [ERRO] N√£o foi poss√≠vel obter cota√ß√£o para {independe_atual}")
                    continue

                # Determina tipo de ordem baseado na posi√ß√£o do dependente
                # Se dependente est√° comprado, independente deve ser vendido (estrat√©gia de pair trading)
                tipo_ordem = mt5.ORDER_TYPE_SELL if posicao.type == mt5.POSITION_TYPE_BUY else mt5.ORDER_TYPE_BUY
                preco = symbol_info_tick.bid if tipo_ordem == mt5.ORDER_TYPE_SELL else symbol_info_tick.ask
                volume = posicao.volume  # Usa mesmo volume da posi√ß√£o dependente

                # Prepara ordem a mercado (sem comment para evitar erro)
                ordem_mercado = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": independe_atual,
                    "volume": volume,
                    "type": tipo_ordem,
                    "price": preco,
                    "magic": magic,
                    "type_time": mt5.ORDER_TIME_DAY,
                    "type_filling": mt5.ORDER_FILLING_RETURN,
                }
                
                # Executa ordem a mercado
                result_envio = mt5.order_send(ordem_mercado)
                if result_envio and result_envio.retcode == mt5.TRADE_RETCODE_DONE:
                    self.log(f"‚úÖ [OK] Ordem a mercado enviada para o independente ({independe_atual}) do magic {magic}")
                else:
                    retcode = getattr(result_envio, 'retcode', None) if result_envio else None
                    self.log(f"‚ùå [ERRO] Falha ao enviar ordem a mercado para o independente ({independe_atual}) do magic {magic}. Retcode: {retcode}")
                    
        except Exception as e:
            self.log(f"‚ùå ERRO na convers√£o de ordem pendente: {str(e)}")
    
    def calcular_lucros_por_magic(self, magics_abertas, posicoes_abertas):
        """Calcula lucros/preju√≠zos por magic - baseado na fun√ß√£o calcular_lucro_prejuizo_por_magic do calculo_entradas_v55.py"""
        import MetaTrader5 as mt5
        
        self.log("üí∞ AN√ÅLISE DE LUCROS/PREJU√çZOS POR MAGIC:")
        
        for magic in magics_abertas:
            lucro_prejuizo = 0.00
            
            # Calcula lucro/preju√≠zo para cada posi√ß√£o do magic
            for posicao in posicoes_abertas:
                if posicao.magic == magic:
                    symbol = posicao.symbol
                    type_pos = posicao.type
                    volume = posicao.volume
                    open_price = posicao.price_open
                    close_price = posicao.price_current if posicao.price_current else mt5.symbol_info_tick(symbol).bid
                    
                    # Calcula P&L baseado no tipo de posi√ß√£o
                    if type_pos == mt5.POSITION_TYPE_BUY:
                        lucro_prejuizo += (close_price - open_price) * volume
                    else:
                        lucro_prejuizo += (open_price - close_price) * volume
            
            status = "üü¢" if lucro_prejuizo > 0 else "üî¥" if lucro_prejuizo < 0 else "‚ö™"
            self.log(f"   Magic {magic}: {status} R$ {lucro_prejuizo:+.2f}")
            
            # Verifica limites (configur√°veis)
            limite_lucro = 120.0
            limite_prejuizo = 120.0
            
            if lucro_prejuizo >= limite_lucro:
                self.log(f"   üö® LIMITE M√ÅXIMO ATINGIDO: Magic {magic} (R$ {lucro_prejuizo:.2f})")
                # Aqui poderia chamar fechamento autom√°tico se necess√°rio
                self.programar_fechamento_posicao(magic, posicoes_abertas)
            elif lucro_prejuizo <= -limite_prejuizo:
                self.log(f"   üö® LIMITE DE PREJU√çZO ATINGIDO: Magic {magic} (R$ {lucro_prejuizo:.2f})")
                # Aqui poderia chamar fechamento autom√°tico se necess√°rio
                self.programar_fechamento_posicao(magic, posicoes_abertas)

    def iniciar_sistema(self):
        """Inicia o sistema completo com todas as threads"""
        self.log("üéØ SISTEMA INTEGRADO DE TRADING - OPERA√á√ïES REAIS")
        self.log("=" * 80)
        self.log("Este sistema executa:")
        self.log("‚úÖ Monitoramento de posi√ß√µes reais")
        self.log("‚úÖ Identifica√ß√£o autom√°tica de pares")
        self.log("‚úÖ Fechamento de posi√ß√µes √≥rf√£s")
        self.log("‚úÖ Convers√£o de ordens pendentes")
        self.log("‚úÖ An√°lise de lucros/preju√≠zos")
        self.log("=" * 80)
        
        self.running = True
        self.dados_sistema["inicio"] = datetime.now()
        self.dados_sistema["status"] = "Iniciando"
        
        # Thread principal do sistema de trading
        thread_trading = threading.Thread(target=self.executar_sistema_original, name="SistemaTrading")
        
        # Thread de monitoramento geral
        thread_monitor = threading.Thread(target=self.thread_monitoramento, name="Monitoramento")
        
        # Thread de monitoramento de posi√ß√µes (pernas √≥rf√£s, convers√µes)
        thread_monitor_posicoes = threading.Thread(target=self.thread_monitoramento_posicoes, name="MonitoramentoPosicoes")
        
        # Inicia todas as threads
        thread_trading.start()
        thread_monitor.start()
        thread_monitor_posicoes.start()
        
        self.log("‚úÖ Todas as threads iniciadas - Sistema operacional!")
        self.log("üîç Thread de monitoramento de posi√ß√µes: A cada 30 segundos")
        self.log("üí° Pressione Ctrl+C para parar o sistema")
        
        try:
            # Aguarda interrup√ß√£o
            while self.running:
                time.sleep(5)
                
                # Verifica se threads est√£o vivas
                threads_status = {
                    "Trading": thread_trading.is_alive(),
                    "Monitoramento": thread_monitor.is_alive(),
                    "Posi√ß√µes": thread_monitor_posicoes.is_alive()
                }
                
                for nome, status in threads_status.items():
                    if not status:
                        self.log(f"‚ö†Ô∏è AVISO: Thread {nome} parou")
        
        except KeyboardInterrupt:
            self.log("üõë INTERRUP√á√ÉO: Parando sistema...")
            self.parar_sistema()
            
        # Aguarda threads finalizarem
        threads = [thread_trading, thread_monitor, thread_monitor_posicoes]
        for thread in threads:
            thread.join(timeout=10)
        
        self.log("üèÅ SISTEMA FINALIZADO")
    
    def parar_sistema(self):
        """Para o sistema"""
        self.running = False
        self.dados_sistema["status"] = "Parando"
        
        # Salva relat√≥rio final
        self.salvar_relatorio()
    
    def salvar_relatorio(self):
        """Salva relat√≥rio final"""
        try:
            relatorio = {
                "resumo": self.dados_sistema,
                "duracao_total": str(datetime.now() - self.dados_sistema["inicio"]) if self.dados_sistema["inicio"] else "N/A",
                "log_completo": self.logs,
                "timestamp_relatorio": datetime.now().isoformat(),
                "configuracoes": {
                    "prefixo_magic": self.prefixo,
                    "apenas_operacoes_reais": True
                }
            }
            
            arquivo = f"relatorio_sistema_real_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            
            with open(arquivo, 'w', encoding='utf-8') as f:
                json.dump(relatorio, f, indent=2, ensure_ascii=False, default=str)
            
            self.log(f"üíæ RELAT√ìRIO: Salvo em {arquivo}")
        except Exception as e:
            self.log(f"‚ùå ERRO ao salvar relat√≥rio: {str(e)}")

def main():
    """Fun√ß√£o principal"""
    # Configure o terminal para UTF-8 no Windows
    if os.name == 'nt':  # Windows
        os.system('chcp 65001 > nul')  # UTF-8 code page
    
    print("üéØ SISTEMA INTEGRADO DE TRADING - OPERA√á√ïES REAIS")
    print("Monitoramento de posi√ß√µes reais do MetaTrader5")
    print("Funcionalidades:")
    print("  üìä Identifica√ß√£o autom√°tica de pares")
    print("  üîÑ Fechamento de posi√ß√µes √≥rf√£s")
    print("  üí± Convers√£o de ordens pendentes")
    print("  üí∞ An√°lise de lucros/preju√≠zos")
    print("=" * 80)
    
    sistema = SistemaIntegrado()
    sistema.iniciar_sistema()

if __name__ == "__main__":
    main()
